# Правила архітектури: IntervalCards Telegram Bot

Ці правила фіксують ключові рішення та конвенції для розвитку IntervalCardsTelegramBot. Вони призначені як контекст для LLM під час подальшої розробки.

## 1. Структура модулів

1. **Розділення відповідальностей:** проєкт будується з окремих модулів:
    - **Entry/Adapter шар:** `src/index.ts` — лише bootstrap і підключення обробників подій. Жодної бізнес‑логіки чи звернень до БД.
    - **Сервіси:** кожна доменна зона — окремий сервіс (`MessageService`, `ScheduleService`, `DbAwsService`). Сервіси мають залежати від інтерфейсів (наприклад, `IDbService`), а не від конкретних реалізацій.
    - **Хелпери й константи:** чисті утиліти та константи — у `src/helpers` і `src/const`. Хелпери — без side‑effects.
2. **DI (інʼєкція залежностей):** сервіси створюються у точці входу та явно передаються вниз. Не використовувати глобальні синглтони.
3. **Без “склейки шарів”:** UI/Telegram‑код не ходить у DynamoDB напряму — тільки через `DbAwsService`. `DbAwsService` не має залежати від Telegram‑обʼєктів.

## 2. FSM (Finite State Machine)

1. **Стан — джерело істини:** `UserStatus` і `interval` зберігаються в DynamoDB, щоб пережити рестарти.
2. **Явні переходи:** будь‑яка зміна стану — тільки від конкретної дії користувача (команда/кнопка). При вході в стан одразу писати `setUserStatus`.
3. **Неочікуваний ввід:** якщо повідомлення не відповідає очікуванню стану — ігнор або коротка підказка; стан не змінювати; не падати.
4. **Переривання станів:** будь‑яка нова команда/кнопка може перевизначити поточний стан (актуальний — “останній”).

## 3. Дизайн БД (DynamoDB)

1. **Таблиці:** рівно 2 таблиці — `users` і `words`.
    - `users`: `_id`, `status`, `interval`
    - `words`: `_id`, `user_id`, `word`, опційно `translation`, `example`, `comment`
2. **Патерни доступу (поточні):** прості `Scan` з фільтрацією за `user_id` або `status`. GSI не додаємо без реальної потреби.
3. **Eventual consistency:** стандартно достатньо eventual reads.
4. **Ключі `words`:** композитний ключ (`_id`, `user_id`) для однозначного видалення елемента.
5. **Без “жорстких” міграцій:** нові поля додаються backward‑compatible (nullable/optional). Без ламання старих даних.

## 4. Правила планувальника

1. **Окремий job на користувача:** кожен user у навчанні має свій cron‑job. Не робити “глобальний” job, який перебирає всіх.
2. **dev vs prod:**
    - dev: кожні `DEVELOPER_MODE_BOT_SENDS_MESSAGE_SEC` секунд
    - prod: кожні *interval* годин у 09:00–22:00
3. **Resume на старті:** на запуску відновлювати сесії для `status=START_LEARN`.
4. **Ідемпотентність:** при повторному старті навчання спершу зупинити попередній job цього користувача, потім створити новий.

## 5. Команди та UX

1. **Команди/кнопки:** `/start`, `/instruction`, `/set_interval`, `/set_favorite_categories`, `/my_status` + кнопки меню (`Show all words`, `Add word`, `Remove word`, `Start learning`, `Stop learn`).
2. **Inline‑клавіатури:**
    - вибір інтервалу
    - видалення слова (натискання по слову)
3. **Без підтвердження видалення:** натиснув — видалили; завжди повернути користувачу success/error.
4. **Розширення фіч:** нові фічі додаються через нові стани/кнопки без руйнування існуючих флоу.

## 6. Безпека (мінімально достатня)

1. **Секрети:** `TELEGRAM_BOT_TOKEN`, AWS креденшали, назви таблиць — лише через env/secret‑storage. Ніколи не комітити в репозиторій і не логувати.
2. **Least privilege:** IAM має дозволяти тільки потрібні дії тільки для потрібних таблиць.
3. **Захист від abuse:**
    - валідація вводу
    - escape для Markdown/HTML (наприклад `escapeMarkdownV2`)
    - базовий захист від flood/великих payload
4. **Розділення середовищ:** різні токени/таблиці для dev/stage/prod (зараз можна без stage, але правило — так).

## 7. Конфіг і спостережуваність

1. **Єдиний конфіг:** усі значення — через env або config‑модуль/константи.
2. **Логи мінімум:**
    - update received
    - state transition
    - message sent
    - dynamodb error
      Формат: хоча б у файл (пізніше — CloudWatch).
3. **Метрики — потім:** зараз не обовʼязково; закласти місця для підрахунків (sent count, errors).

## 8. Стандарти коду

1. **TypeScript:** тримати типізацію; `any` — небажано, але допускається точково.
2. **Помилки:** кидати `throw` у сервісах для “неочікуваного”; в хендлерах — ловити, логувати, відповідати користувачу.
3. **Залежності AWS SDK:** зараз не “ламаємо” (v2 може бути присутній випадково), але всі нові зміни робити на AWS SDK v3.

## 9. LLM та генерація контенту

1. **OpenRouter API:** основний провайдер для LLM. Секрети (API ключ) — тільки через `.env`.
2. **Кешування:** усі згенеровані набори слів мають кешуватися (in-memory) на 24 години для мінімізації витрат та затримок.
3. **Промпти:** системні інструкції (prompts) мають бути винесені в окремі константи (`src/const/prompts.ts`).
4. **Обробка помилок:** LLM сервіс повинен коректно обробляти та логувати помилки API (401, 429, 5xx), повертаючи користувачу зрозумілі повідомлення.
5. **Валідація:** відповіді від LLM (JSON) обов'язково мають проходити валідацію структури перед використанням.

## 10. Майбутні зміни (орієнтири)

- Preset слів (наприклад 100 random words).
- Категорії/“favourite” у налаштуваннях.
- Мультимовність (мінімум 3 мови) та підписка (premium).
